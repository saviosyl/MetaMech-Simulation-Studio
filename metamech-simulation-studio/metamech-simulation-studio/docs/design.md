<!--
  This file is automatically generated from the assistant's research.  Do not edit
  directly unless you are updating the design specification.  See the original
  source for more information.
-->

# MetaMech Simulation Studio – Implementation Plan

## Overview

MetaMech Simulation Studio is a web‑native, premium industrial simulation platform.  Users log in and use a drag‑and‑drop editor to build process flow models, add environment assets and actor animations, run deterministic simulations and export HD videos.  The platform must be general enough for conveyors, machines, transfers, spiral conveyors, lifters, palletizing, robotics and full warehouse environments.  A high‑level plan is necessary to deliver the project in well‑defined milestones, ensure performance targets (≥60 FPS on medium scenes) and maintain premium visuals.

Key design drivers include:

- **WebGL 2.0 and PBR** – Physically based rendering provides realistic materials.  WebGL 2.0 offers high compatibility (94 % of browsers) and can maintain ~60 FPS on low‑end devices with 2 GB RAM【678833981756235†L52-L59】.  The glTF 2.0 format is used for assets because it produces small file sizes and supports PBR materials that mimic how surfaces react to light【678833981756235†L88-L91】.
- **GPU instancing** – Scenes will contain many repeated modules.  Instancing is a 3D optimisation that batches identical meshes into a single draw call, dramatically reducing CPU overhead【889174252875384†L505-L509】.  Three.js exposes instancing via `InstancedMesh` with per‑instance attributes【889174252875384†L505-L560】.
- **Simulation engine in a worker** – To keep the UI responsive, the deterministic simulation runs in a Web Worker.  The render loop stays on the main thread, decoupled from simulation time steps.
- **Cloud‑native** – All projects are stored in PostgreSQL (JSONB) with autosave and version control.  Users can export/import `.metamech-sim.json` files and export simulation videos (WebM at 1080p).  Authentication supports email/password with roles (User, Org Admin, Admin).

## Architecture

### Front‑end

- **Framework**: React with TypeScript.  Components will be organised as library panels, property inspectors, 3D viewport and top bar.  A separate route serves the login and projects dashboard.
- **Rendering engine**: Three.js with WebGL 2.0.  Use the PBR pipeline with an HDRI environment map and filmic tonemapping.  Scenes support multiple quality presets (Ultra/High/Medium).  GPU instancing will be used for repeated conveyor segments and pallets【889174252875384†L505-L560】.  Textures are compressed via Basis/ETC to reduce memory usage.
- **3D asset library**: All models are glTF/GLB with PBR textures (BaseColor, Normal, Roughness, Metallic, AO).  Scale is in metres.  Each asset includes LOD0/LOD1/LOD2 versions.  A caching layer (IndexedDB) stores downloaded assets client‑side.
- **Editor UI**: Divided into panels:
  - **Library**: Tabs for Process, Environment and Actors.  Users drag items into the scene.  Assets are fetched lazily and cached.
  - **Viewport**: 3D view with CAD‑style navigation (orbit/pan/zoom) and transform gizmos.  Scene supports grid, axes, selection highlighting and smooth camera controls.
  - **Inspector**: Shows parameters for selected objects, allowing editing (dimensions, speeds, capacities, etc.).
  - **Top bar**: Play/pause/reset simulation, time‑scale control (0.25× – 4×), scenario selector and video export.
  - **Bottom bar** (optional): Event log and KPI summary.

### Back‑end

- **API**: Node.js (Express or Nest) with TypeScript.  Endpoints handle authentication (`/auth/register`, `/login`, `/logout`, `/forgot‑password`, `/reset‑password`) and projects (`/projects` CRUD).  A future `/uploads` endpoint stores underlay images and exported videos in S3 or local storage.
- **Database**: PostgreSQL.  Users table stores hashed passwords and roles.  Projects table stores project JSON (schema version, units, scene settings, process nodes, environment assets, actors, underlays, etc.) as JSONB.  Version history may store snapshots.
- **Simulation service**: The server does not run simulations; all process simulation occurs in the client via Web Workers.  However, the server may perform heavy conversions (e.g., DWG→SVG or MP4 encoding) using separate micro‑services.

## Simulation Layers

1. **Process simulation layer** – Directed graphs of nodes (modules) connected by ports.  Each module implements a plugin contract: type, ports, parameter schema, renderAsset reference and `simulateStep(dt, context)`.  The simulation loop (fixed time step) runs in a Web Worker.  It applies blocking/queue rules and generates events (blocked, starved, jammed).  Core modules include Source, Sink, Transport (conveyor), Buffer, Process Machine and Router.  Advanced modules (transfer bridges, spiral conveyors, vertical lifters, pick‑and‑place robots, palletizers) extend the same contract.

2. **Environment layer** – Visual layout of walls, doors, windows, stairs, racks and building shell.  Users can import underlay images (PNG/JPG/WEBP) and calibrate scale via point‑to‑point measurement.  A server‑side conversion service converts DWG/DXF to SVG or PNG for display.

3. **Actors and moving equipment layer** – Avatars (operator and engineer) and vehicles (forklift, AGV) follow waypoint paths.  Users author paths with speed controls.  Actors/equipment move in sync with simulation time.  The timeline may support camera keyframes in later versions.

## Performance & Visual Quality

Premium visuals require PBR materials, HDRI environment lighting and soft shadows.  Scenes must remain smooth; therefore:

- Use level‑of‑detail (LOD) switching and GPU instancing for repeated assets【889174252875384†L505-L560】.
- Compress textures using Basis/ETC and generate mipmaps to avoid aliasing.
- Implement frustum culling and (optionally) occlusion culling to hide off‑screen meshes.
- Progressive loading: fetch assets on demand and stream heavy models incrementally to keep time‑to‑interactive under 5 s.  A skeleton loader may show placeholders while loading.
- Use an adaptive quality system: reduce shadows/SSAO/anti‑aliasing for large scenes to maintain ≥30 FPS.

## Project Schema

Projects are saved as JSON with schema versioning.  The minimal structure is:

```json
{
  "schemaVersion": 3,
  "name": "Project Name",
  "units": "mm | m",
  "scene": { /* scene presets, HDRI, floor, background, lighting */ },
  "camera": { /* camera position, orientation, FOV, etc. */ },
  "processNodes": [ /* modules with params and placement */ ],
  "processEdges": [ /* connections between ports */ ],
  "scenarios": [ /* scenario definitions */ ],
  "environmentAssets": [ /* walls, doors, racks, etc. */ ],
  "actors": [ /* avatars and vehicles with path data */ ],
  "underlays": [ /* imported images or DWG conversions + calibration data */ ]
}
```

## Milestones

1. **M1 – Core site integration and authentication**
   - Add a “MetaMech Simulation Studio” button on the metamechsolutions.com home page (hero section).  It links directly to the login page of the simulation app at `https://app.metamechsolutions.com` (preferred) or a route such as `/simulation‑studio`.
   - Implement user registration, login, password reset and secure sessions (HTTP‑only cookies).  Provide user and admin roles.  Build a projects dashboard (create/open/rename/duplicate/delete projects).  Use a MetaMech visual theme.

2. **M2 – Editor shell and environment basics**
   - Build the editor UI: 3D viewport with navigation and transform gizmos; library panel for process/environment/actors; properties inspector; top bar for simulation controls.
   - Implement PBR rendering with HDRI lighting, soft shadows, anti‑aliasing and tonemapping.  Provide scene presets (factory floor, studio white, dark showroom, transparent).  Add environment kit assets (floor, walls, doors/windows, stairs) and implement image underlay import with point‑to‑point scaling.

3. **M3 – Process simulation engine and core modules**
   - Develop the deterministic simulation engine in a Web Worker.  Implement Source, Sink, Transport (conveyor), Buffer, Process Machine and Router modules with ports and parameter schemas.  Ensure blocking/queue rules and event generation.  Provide basic KPIs: throughput, WIP, lead time, utilization, queue length.  Highlight bottlenecks based on highest utilization or longest queues.

4. **M4 – Advanced handling modules and actors**
   - Add transfer bridges (gap bridge, pop‑up, pusher), spiral conveyors, vertical lifters, pallet racks and palletizer.  Implement handshake logic and capacity constraints.  Develop actor and equipment models with waypoint path authoring and sync them with simulation time.

5. **M5 – Video export and optimization**
   - Implement video capture of the simulation.  Output 1080p WebM (and optionally MP4 via server).  Include items, environment, actors and selected scene preset.  Support duration range, hide UI and watermark toggle.  Provide three demo projects (conveyor warehouse, process line with routers/buffers, pallet staging with forklift path) and an exported showcase video.  Perform performance tuning: texture compression, instancing, LOD, progressive streaming, caching.

6. **M6 – Optional enhancements**
   - Develop full pick‑and‑place cell animations, timeline/camera shots, batch scenario runner and richer KPI reporting.

## Next Steps

The next implementation step is to start M1 by creating a new repository with separate front‑end and back‑end folders.  Set up the authentication endpoints, integrate PostgreSQL and build the login and projects dashboard with the MetaMech theme.  Once authentication is stable, proceed to implement the 3D editor shell and environment assets in M2, ensuring PBR rendering and performance targets.

## Sources

- WebGL 2.0 provides high browser compatibility and can achieve 60 FPS on low‑end devices, while Three.js offers tools for building complex 3D scenes【678833981756235†L52-L59】.
- The glTF 2.0 format is the de‑facto standard for web 3D models because it has small file sizes and supports PBR materials【678833981756235†L88-L91】.
- GPU instancing reduces the number of draw calls by batching multiple clones of the same geometry into a single draw call, as implemented in Three.js’s `InstancedMesh`【889174252875384†L505-L560】.